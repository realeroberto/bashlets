#!/bin/bash


################################################################################
#                                         
# |              |    |         |         
# |---.,---.,---.|---.|    ,---.|--- ,---.
# |   |,---|`---.|   ||    |---'|    `---.
# `---'`---^`---'`   '`---'`---'`---'`---'
#
#                                        
# Bashlets -- A modular extensible toolbox for Bash
#
# Copyright (c) 2014-6 Roberto Reale
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
################################################################################


source bashlet datatype/number


# favours lower powers...

function bashlets_perl_math_biased_rand()
{
    local n=${1:-1000} rand

    number validate_as_unsigned $n || return 1

    rand="$(perl -e '
        # log() is to favour lower powers
        my $n = $ARGV[0];
        my $exp = int(log(rand($n)));
        print int(rand(10**$exp));
    ' $n)"

    echo $rand
}


# Euclidean algorithm
#
# inspired by the C implementation at http://www.codecodex.com/wiki/Euclidean_algorithm

function bashlets_perl_math_gcd()
{
    local x=${1:-1} y=${2:-1} gcd

    number validate_as_unsigned $x || return 1
    number validate_as_unsigned $y || return 1

    gcd="$(perl -e '
        use warnings;

        sub gcd {
            my $a = shift;
            my $b = shift;
            
            if ($b == 0) {
                return $a;
            }
            
            return gcd($b, $a % $b);
        }

        print gcd($ARGV[0], $ARGV[1]);
    ' $x $y)"

    echo $gcd
}



# factorize into prime factors...
#
# inspired by http://www.btinternet.com/~se16/js/factor.htm

function bashlets_perl_math_factorize_integer()
{
    local n=${1:-0} factors

    number validate_as_unsigned $n || return 1

    factors="$(perl -e '
        use warnings;

        sub factorize {
            my $n = $_[0];
            my $factor = 2;
            my $res = "";

            while ($factor * $factor <= $n) {
                if ($n % $factor == 0) {
                    $res = $res . $factor;
                    $n = $n / $factor;

                    if ($n > 1) {
                        # prepare for the next factor
                        $res = $res . "\n";
                    }
                } else {
                    # try next factor
                    $factor++;
                }
            }

            if ($n > 1) {
                # last factor remaining
                $res = $res . $n;
            }

            return $res;
        }


        print factorize($ARGV[0]); 
    ' $n)"

    echo $factors
}


# calculate the determinant of a square matrix, the slow old way...

function bashlets_perl_math_det()
{
    local det

    det="$(perl -e '
        use warnings;

        sub det {
            my $n = shift;
            my @matrix = @_;
            my $res = 0;

            if ($n == 1) {
                $res = $matrix[0][0];
            } else {
                for (my $i = 0; $i < $n; $i++) {
                    my @submatrix = ();

                    for (my $h = 1; $h < $n; $h++) {
                        for (my $k = 0; $k < $n - 1; $k++) {
                            my $k1 = ($k < $i) ? $k : ($k + 1);
                            $submatrix[$h - 1][$k] = $matrix[$h][$k1];
                        }
                    }
                    $res += (-1)**(1 + ($i + 1)) * $matrix[0][$i] * det($n - 1, @submatrix);
                }
            }
            return $res;
        }


        my $ntimesn = @ARGV;
        my $n = sqrt($ntimesn);
        exit 1 if $n * $n != $ntimesn;  # non-square matrix

        my @matrix = ();
        
        for (my $i = 0; $i < $n; $i++) {
            for (my $j = 0; $j < $n; $j++) {
                $matrix[$i][$j] = $ARGV[$i * $n + $j];
            }
        }

        print det($n, @matrix);
    ' $@)" || return 1

    echo $det
}

# Local variables:
# mode: shell-script
# sh-basic-offset: 4
# sh-indent-comment: t
# indent-tabs-mode: nil
# End:
# ex: ts=4 sw=4 et filetype=sh
