#!/bin/bash


################################################################################
#                                         
# |              |    |         |         
# |---.,---.,---.|---.|    ,---.|--- ,---.
# |   |,---|`---.|   ||    |---'|    `---.
# `---'`---^`---'`   '`---'`---'`---'`---'
#
#                                        
# Bashlets -- A modular extensible toolbox for Bash
#
# Copyright (c) 2016 Roberto Reale
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
################################################################################

BASHLETS_PARSER_JSON_BACKEND=native


################################################################################
#
# Based on JSON.sh, cf. https://github.com/dominictarr/JSON.sh
#
# Requires GNU awk
#
################################################################################

################################################################################
#
# Global Variables
#
#
#   BASHLETS_PARSER_JSON_ERROR_RING
#   The parser's error ring
#
#   BASHLETS_PARSER_JSON_LEAFONLY
#   Leaf only mode: only show leaf nodes, which stops data duplication
#   
#   BASHLETS_PARSER_JSON_PRUNE
#   Prune empty mode: exclude fields with empty values
#
#   BASHLETS_PARSER_JSON_BRIEF
#   Combines 'Leaf only' and 'Prune empty' modes
#
#   BASHLETS_PARSER_JSON_NO_HEAD
#   Do not show nodes that have no path (lines that start with [])
#
#   BASHLETS_PARSER_JSON_NORMALIZE_SOLIDUS
#   Remove escaping of the solidus symbol (straight slash)
#
#   BASHLETS_PARSER_JSON_LEAVES_AS_DIRS
#   Determines how the JSON-to-fs translator should represent leaf nodes
#
################################################################################



#@method
function __bashlets_parser_json_throw()
{
   BASHLETS_PARSER_JSON_ERROR_RING="$*"
}

#@method
function __bashlets_parser_json_tokenize()
{
    local GREP
    local ESCAPE
    local CHAR

    function __bashlets_parser_json_awk_egrep()
    {
        local pattern_string=$1

        gawk '{
            while ($0) {
                start=match($0, pattern);
                token=substr($0, start, RLENGTH);
                print token;
                $0=substr($0, start+RLENGTH);
            }
        }' pattern="$pattern_string"
    }

    if echo "test string" | egrep -ao --color=never "test" >/dev/null 2>&1
    then
        GREP='egrep -ao --color=never'
    else
        GREP='egrep -ao'
    fi

    if echo "test string" | egrep -o "test" >/dev/null 2>&1
    then
        ESCAPE='(\\[^u[:cntrl:]]|\\u[0-9a-fA-F]{4})'
        CHAR='[^[:cntrl:]"\\]'
    else
        GREP=__bashlets_parser_json_awk_egrep
        ESCAPE='(\\\\[^u[:cntrl:]]|\\u[0-9a-fA-F]{4})'
        CHAR='[^[:cntrl:]"\\\\]'
    fi

    local STRING="\"$CHAR*($ESCAPE$CHAR*)*\""
    local NUMBER='-?(0|[1-9][0-9]*)([.][0-9]*)?([eE][+-]?[0-9]*)?'
    local KEYWORD='null|false|true'
    local SPACE='[[:space:]]+'

    $GREP "$STRING|$NUMBER|$KEYWORD|$SPACE|." | egrep -v "^$SPACE$"

    unset __bashlets_parser_json_awk_egrep
}

#@method
function __bashlets_parser_json_parse_array()
{
    local index=0
    local ary=''

    read -r token

    case "$token" in
        ']') ;;
        *)
            while :
            do
                __bashlets_parser_json_parse_value "$1" "$index"
                index=$((index+1))
                ary="$ary""$value" 
                read -r token
                case "$token" in
                    ']') break ;;
                    ',') ary="$ary," ;;
                    *) __bashlets_parser_json_throw "EXPECTED , or ] GOT ${token:-EOF}" ; return 1 ;;
                esac
                read -r token
            done
    ;;
    esac
    [[ "$BASHLETS_PARSER_JSON_BRIEF" -eq 0 ]] && value=$(printf '[%s]' "$ary") || value=
    :
}

#@method
function __bashlets_parser_json_parse_object()
{
    local key
    local obj=''

    read -r token

    case "$token" in
        '}') ;;
        *)
            while :
            do
                case "$token" in
                    '"'*'"') key=$token ;;
                    *) __bashlets_parser_json_throw "EXPECTED string GOT ${token:-EOF}" ; exit 1 ;;
                esac
                read -r token
                case "$token" in
                    ':') ;;
                    *) __bashlets_parser_json_throw "EXPECTED : GOT ${token:-EOF}" ; exit 1 ;;
                esac
                read -r token
                __bashlets_parser_json_parse_value "$1" "$key"
                obj="$obj$key:$value"        
                read -r token
                case "$token" in
                    '}') break ;;
                    ',') obj="$obj," ;;
                    *) __bashlets_parser_json_throw "EXPECTED , or } GOT ${token:-EOF}" ; exit 1 ;;
                esac
                read -r token
            done
        ;;
    esac
    [[ "$BASHLETS_PARSER_JSON_BRIEF" -eq 0 ]] && value=$(printf '{%s}' "$obj") || value=
    :
}

#@method
function __bashlets_parser_json_parse_value()
{
    local jpath="${1:+$1/}$2" isleaf=0 isempty=0 print=0
    case "$token" in
        '{')
            __bashlets_parser_json_parse_object "$jpath" ;;
        '[')
            __bashlets_parser_json_parse_array  "$jpath" ;;
        # At this point, the only valid single-character tokens are digits.
        ''|[!0-9])
            __bashlets_parser_json_throw "EXPECTED value GOT ${token:-EOF}" ; return 1;;
        *)
            value=$token
            # if asked, replace solidus ("\/") in json strings with normalized value: "/"
            [[ "$BASHLETS_PARSER_JSON_NORMALIZE_SOLIDUS" -eq 1 ]] && value=$(echo "$value" | sed 's#\\/#/#g')
            isleaf=1
            [ "$value" = '""' ] && isempty=1
            ;;
    esac

    [ "$value" = '' ] && return
    [[ "$BASHLETS_PARSER_JSON_NO_HEAD" -eq 1 ]] && [ -z "$jpath" ] && return

    [[ "$BASHLETS_PARSER_JSON_LEAFONLY" -eq 0 ]] && [[ "$BASHLETS_PARSER_JSON_PRUNE" -eq 0 ]] && print=1
    [[ "$BASHLETS_PARSER_JSON_LEAFONLY" -eq 1 ]] && [ "$isleaf" -eq 1 ] && [ $BASHLETS_PARSER_JSON_PRUNE -eq 0 ]] && print=1
    [[ "$BASHLETS_PARSER_JSON_LEAFONLY" -eq 0 ]] && [[ "$BASHLETS_PARSER_JSON_PRUNE" -eq 1 ]] && [ "$isempty" -eq 0 ] && print=1
    [[ "$BASHLETS_PARSER_JSON_LEAFONLY" -eq 1 ]] && [ "$isleaf" -eq 1 ] && \
    [[ "$BASHLETS_PARSER_JSON_PRUNE" -eq 1 ]] && [ $isempty -eq 0 ] && print=1
    [ "$print" -eq 1 ] && printf "%s\t%s\n" "$jpath" "$value"
    :
}

#@method
function bashlets_parser_json_parse()
{
    if [[ $BASHLETS_PARSER_JSON_BACKEND == native ]]
    then
        read -r token
        __bashlets_parser_json_parse_value
        read -r token
        case "$token" in
            '') ;;
            *) __bashlets_parser_json_throw "EXPECTED EOF GOT $token" ; return 1 ;;
        esac
    fi
}

#@method
function bashlets_parser_json_to_charstream()
{
    if [[ $BASHLETS_PARSER_JSON_BACKEND == native ]]
    then
        __bashlets_parser_json_tokenize | bashlets_parser_json_parse
    fi
}

#@method
function bashlets_parser_json_to_fs()
{
    local base="${1:-/tmp}"

    # 'Brief' mode is requires, so we save the current settings
    local old_BASHLETS_PARSER_JSON_BRIEF=$BASHLETS_PARSER_JSON_BRIEF
    export BASHLETS_PARSER_JSON_BRIEF=1

    bashlets_parser_json_to_charstream | while read jpath value
    do
        jpath=$(echo $jpath | xargs echo)  # unquote

        if [[ "$BASHLETS_PARSER_JSON_LEAVES_AS_DIRS" -eq 1 ]]
        then
            value=$(echo $value | xargs echo)  # unquote
            mkdir -p $base/$jpath/"$value"
        else
            mkdir -p $(dirname $base/$jpath)
            echo "$value" > $base/$jpath
        fi
    done

    # restore the old settings
    export BASHLETS_PARSER_JSON_BRIEF=$old_BASHLETS_PARSER_JSON_BRIEF
}


# Local variables:
# mode: shell-script
# sh-basic-offset: 4
# sh-indent-comment: t
# indent-tabs-mode: nil
# End:
# ex: ts=4 sw=4 et filetype=sh
