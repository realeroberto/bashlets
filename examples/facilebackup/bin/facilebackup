#!/bin/bash


################################################################################
#
# |              |    |         |
# |---.,---.,---.|---.|    ,---.|--- ,---.
# |   |,---|`---.|   ||    |---'|    `---.
# `---'`---^`---'`   '`---'`---'`---'`---'
#
#
# Bashlets -- A modular extensible toolbox for Bash
#
# Copyright (c) 2014-6 Roberto Reale
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
################################################################################


################################################################################
#
# facilebackup
#
#
# Purpose:
#
#    a simple backup manager
#
# Environment variables:
#
#    none
#
# Example of call:
#
#    facilebackup [ -B <BACKEND> ] [ -M <MANIFEST> ]
#
################################################################################


#
# library modules/plugins
################################################################################

source bashlet basic/myself
source bashlet datatype/integer
source bashlet datatype/string
source bashlet datatype/uuid
source bashlet parser/yaml
source bashlet client/webdav
source bashlet ux/repl


#
# global variables
################################################################################

# script version
FACILEBACKUP_VERSION='0.1'
# default MANIFEST
FACILEBACKUP_MANIFEST=~/.facilebackup.yaml
# REPL prompt
FACILEBACKUP_PROMPT="$($BASHLETS_NAMESPACE myself get_name)> "


unset FACILEBACKUP_FS_BASE_PATH
unset FACILEBACKUP_FS_PATH_DELIMITER
unset FACILEBACKUP_WEBDAV_HANDLER
unset FACILEBACKUP_BACKEND
unset FACILEBACKUP_RETENTION
unset FACILEBACKUP_USE_TRASH


#
# utilities
################################################################################

#
# facilebackup_error
#
#
# Purpose:
#
#    prints error message and exits
#
# Example of call:
#
#    facilebackup_error <EXIT_CODE> <ERROR_MESSAGE>
#
# Global variables:
#
#    none
#
# Local variables:
#
#    exit_code, error_message
#

function facilebackup_error()
{
	local exit_code=$1
	shift
	local error_message="$@"

	echo "ERROR:  $error_message"
	exit $exit_code
}


#
# facilebackup_usage
#
#
# Purpose:
#
#    prints usage information
#
# Example of call:
#
#    facilebackup_usage
#
# Global variables:
#
#    FACILEBACKUP_MANIFEST
#
# Local variables:
#
#    none
#

function facilebackup_usage()
{
    cat <<-EOF
		Usage:

		    $($BASHLETS_NAMESPACE myself get_name) [ -B <BACKEND> ] [ -M <MANIFEST> ]

		Options:

		   -B      backend type [available types: $(facilebackup_list_backends)]
		   -M      path to manifest file [default: $FACILEBACKUP_MANIFEST]
		   -h      display this help and exit
		   -V      output version information and exit

	EOF
} 


#
# facilebackup_list_backends
#
#
# Purpose:
#
#    lists available backends
#
# Example of call:
#
#    facilebackup_list_backends
#
# Global variables:
#
#    none
#
# Local variables:
#
#    none
#

function facilebackup_list_backends()
{
	echo "fs webdav"
}


#
# facilebackup_version
#
#
# Purpose:
#
#    prints version information
#
# Example of call:
#
#    facilebackup_version
#
# Global variables:
#
#    FACILEBACKUP_VERSION
#
# Local variables:
#
#    none
#

function facilebackup_version()
{
    cat <<-EOF
		$($BASHLETS_NAMESPACE myself get_name) $FACILEBACKUP_VERSION
	EOF
} 


#
# Backend: FS
#
################################################################################

#
# facilebackup_fs_init
#
#
# Purpose:
#
#    initializes the FS backend
#
# Example of call:
#
#    facilebackup_fs_init
#
# Global variables:
#
#    FACILEBACKUP_MANIFEST, FACILEBACKUP_FS_BASE_PATH,
#    FACILEBACKUP_FS_PATH_DELIMITER
#
# Local variables:
#
#    manifest
#

function facilebackup_fs_init()
{
	function facilebackup_parse_manifest()
	{
		local manifest="$FACILEBACKUP_MANIFEST"

		FACILEBACKUP_FS_BASE_PATH="$(
			$BASHLETS_NAMESPACE yaml get_by_key "$manifest" backends_fs_base_path
		)"
		FACILEBACKUP_FS_PATH_DELIMITER="$(
			$BASHLETS_NAMESPACE yaml get_by_key "$manifest" backends_fs_path_delimiter
		)"
	}

	facilebackup_parse_manifest
}


#
# facilebackup_fs_is_file
#
#
# Purpose:
#
#    returns true if the given target is a file
#
# Example of call:
#
#    facilebackup_fs_is_file <PATH> <TARGET>
#
# Global variables:
#
#    FACILEBACKUP_FS_BASE_PATH, FACILEBACKUP_FS_PATH_DELIMITER
#
# Local variables:
#
#    base_path, del, path, target
#

function facilebackup_fs_is_file()
{
	local base_path="$FACILEBACKUP_FS_BASE_PATH"
	local del="$FACILEBACKUP_FS_PATH_DELIMITER"
	local path="$1"
	local target="$2"

	test -f "${base_path}${del}${path}${del}${target}"
}


#
# facilebackup_fs_create
#
#
# Purpose:
#
#    creates a resource via the FS backend
#
# Example of call:
#
#    facilebackup_fs_create <TARGET>
#
# Global variables:
#
#    FACILEBACKUP_FS_BASE_PATH, FACILEBACKUP_FS_PATH_DELIMITER
#
# Local variables:
#
#    base_path, del, target
#

function facilebackup_fs_create()
{
	local base_path="$FACILEBACKUP_FS_BASE_PATH"
	local del="$FACILEBACKUP_FS_PATH_DELIMITER"
	local target="$1"

	mkdir "${base_path}${del}${target}"
}


#
# facilebackup_fs_touch
#
#
# Purpose:
#
#    touches a resource via the FS backend
#
# Example of call:
#
#    facilebackup_fs_touch <PATH> <TARGET>
#
# Global variables:
#
#    FACILEBACKUP_FS_BASE_PATH, FACILEBACKUP_FS_PATH_DELIMITER
#
# Local variables:
#
#    base_path, del, path, target
#

function facilebackup_fs_touch()
{
	local base_path="$FACILEBACKUP_FS_BASE_PATH"
	local del="$FACILEBACKUP_FS_PATH_DELIMITER"
	local path="$1"
	local target="$2"

	touch "${base_path}${del}${path}${del}${target}"
}


#
# facilebackup_fs_copy
#
#
# Purpose:
#
#    copies a resource via the FS backend
#
# Example of call:
#
#    facilebackup_fs_copy <SOURCE> <TARGET>
#
# Global variables:
#
#    FACILEBACKUP_FS_BASE_PATH, FACILEBACKUP_FS_PATH_DELIMITER
#
# Local variables:
#
#    base_path, del, source, target
#

function facilebackup_fs_copy()
{
	local base_path="$FACILEBACKUP_FS_BASE_PATH"
	local del="$FACILEBACKUP_FS_PATH_DELIMITER"
	local source="$1"
	local target="$2"

	cp -pr "${base_path}${del}${source}" "${base_path}${del}${target}"
}


#
# facilebackup_fs_move
#
#
# Purpose:
#
#    moves a resource via the FS backend
#
# Example of call:
#
#    facilebackup_fs_move <SOURCE> <TARGET>
#
# Global variables:
#
#    FACILEBACKUP_FS_BASE_PATH, FACILEBACKUP_FS_PATH_DELIMITER
#
# Local variables:
#
#    base_path, del, source, target
#

function facilebackup_fs_move()
{
	local base_path="$FACILEBACKUP_FS_BASE_PATH"
	local del="$FACILEBACKUP_FS_PATH_DELIMITER"
	local source="$1"
	local target="$2"

	mv "${base_path}${del}${source}" "${base_path}${del}${target}"
}


#
# facilebackup_fs_get_path
#
#
# Purpose:
#
#    gets a repository path via the FS backend
#
# Example of call:
#
#    facilebackup_fs_get_path <PATH> [ <FULL_PATH> ]
#
# Global variables:
#
#    FACILEBACKUP_FS_BASE_PATH
#
# Local variables:
#
#    path, full_path, base_path
#

function facilebackup_fs_get_path()
{
	local base_path="$FACILEBACKUP_FS_BASE_PATH"
	local path="$1"
	local full_path="$2"

	[[ $full_path == full ]] && echo "${base_path}/${path}" || echo "${path}"
}



#
# Backend: WebDAV
#
################################################################################

#
# facilebackup_webdav_init
#
#
# Purpose:
#
#    initializes the WebDAV backend
#
# Example of call:
#
#    facilebackup_webdav_init
#
# Global variables:
#
#    FACILEBACKUP_MANIFEST, FACILEBACKUP_WEBDAV_HANDLER	
#
# Local variables:
#
#    manifest, base_uri, username, password, handler
#

function facilebackup_webdav_init()
{
	function facilebackup_parse_manifest()
	{
		local manifest="$FACILEBACKUP_MANIFEST"

		local base_uri="$(
			$BASHLETS_NAMESPACE yaml get_by_key "$manifest" backends_webdav_base_uri
		)"
		local username="$(
			$BASHLETS_NAMESPACE yaml get_by_key "$manifest" backends_webdav_username
		)"
		local password="$(
			$BASHLETS_NAMESPACE yaml get_by_key "$manifest" backends_webdav_password
		)"

		local handler

		handler="$($BASHLETS_NAMESPACE webdav get_handler)"
		handler="$($BASHLETS_NAMESPACE webdav set_base_uri "$handler" "$base_uri")"
		handler="$($BASHLETS_NAMESPACE webdav set_username "$handler" "$username")"
		handler="$($BASHLETS_NAMESPACE webdav set_password "$handler" "$password")"

		FACILEBACKUP_WEBDAV_HANDLER="$handler"
	}

	facilebackup_parse_manifest
}


#
# facilebackup_webdav_isfile
#
#
# Purpose:
#
#    returns true if the given target is a file
#
# Example of call:
#
#    facilebackup_webdav_isfile <PATH> <TARGET>
#
# Global variables:
#
#    FACILEBACKUP_WEBDAV_HANDLER
#
# Local variables:
#
#    path, target
#

function facilebackup_webdav_isfile()
{
	local path="$1"
	local target="$2"

	$BASHLETS_NAMESPACE webdav is_file "$FACILEBACKUP_WEBDAV_HANDLER" "$path" "$target"
}


#
# facilebackup_webdav_create
#
#
# Purpose:
#
#    creates a resource via the WebDAV backend
#
# Example of call:
#
#    facilebackup_webdav_create <TARGET>
#
# Global variables:
#
#    FACILEBACKUP_WEBDAV_HANDLER
#
# Local variables:
#
#    target
#

function facilebackup_webdav_create()
{
	local target="$1"

	$BASHLETS_NAMESPACE webdav create "$FACILEBACKUP_WEBDAV_HANDLER" "$target"
}


#
# facilebackup_webdav_touch
#
#
# Purpose:
#
#    touches a resource via the WebDAV backend
#
# Example of call:
#
#    facilebackup_webdav_touch <PATH> <TARGET>
#
# Global variables:
#
#    FACILEBACKUP_WEBDAV_HANDLER
#
# Local variables:
#
#    path, target
#

function facilebackup_webdav_touch()
{
	local path="$1"
	local target="$2"

	$BASHLETS_NAMESPACE webdav touch "$FACILEBACKUP_WEBDAV_HANDLER" "$path" "$target"
}


#
# facilebackup_webdav_copy
#
#
# Purpose:
#
#    copies a resource via the WebDAV backend
#
# Example of call:
#
#    facilebackup_webdav_copy <SOURCE> <TARGET>
#
# Global variables:
#
#    FACILEBACKUP_WEBDAV_HANDLER
#
# Local variables:
#
#    source, target
#

function facilebackup_webdav_copy()
{
	local source="$1"
	local target="$2"

	$BASHLETS_NAMESPACE webdav copy "$FACILEBACKUP_WEBDAV_HANDLER" "$source" "$target"
}


#
# facilebackup_webdav_move
#
#
# Purpose:
#
#    moves a resource via the WebDAV backend
#
# Example of call:
#
#    facilebackup_webdav_move <SOURCE> <TARGET>
#
# Global variables:
#
#    FACILEBACKUP_WEBDAV_HANDLER
#
# Local variables:
#
#    source, target
#

function facilebackup_webdav_move()
{
	local source="$1"
	local target="$2"

	$BASHLETS_NAMESPACE webdav copy "$FACILEBACKUP_WEBDAV_HANDLER" "$source" "$target"
}


#
# facilebackup_webdav_get_path
#
#
# Purpose:
#
#    gets a repository path via the WebDAV backend
#
# Example of call:
#
#    facilebackup_webdav_get_path <PATH> [ <PATH_TYPE> ]
#
# Global variables:
#
#    FACILEBACKUP_WEBDAV_HANDLER
#
# Local variables:
#
#    path, path_type, base_uri
#

function facilebackup_webdav_get_path()
{
	local path="$1"
	local path_type="$2"
	local base_uri="$($BASHLETS_NAMESPACE webdav get_base_uri "$FACILEBACKUP_WEBDAV_HANDLER")"

	[[ $path_type == full ]] && echo "${base_uri}/${path}" || echo "${path}"
}



#
# Repository management
#
################################################################################

# TODO: implement



#
# Branch management
#
################################################################################

# TODO: explain branches

#
# facilebackup_isbranch
#
#
# Purpose:
#
#    returns true if the given target is a backup branch
#
# Example of call:
#
#    facilebackup_isbranch <TARGET>
#
# Global variables:
#
#    FACILEBACKUP_BACKEND
#
# Local variables:
#
#    target, backend, magic
#

function facilebackup_isbranch()
{
	local target="$1"
	local backend="$FACILEBACKUP_BACKEND"
	local magic=".$($BASHLETS_NAMESPACE myself get_name)"

	facilebackup_"${backend}_isfile" "$target" "$magic"
}


#
# facilebackup_get_numbered_branch
#
#
# Purpose:
#
#    gets a branch by number
#
# Example of call:
#
#    facilebackup_get_numbered_branch <N> [ <FULL_PATH> ]
#
# Global variables:
#
#    FACILEBACKUP_BACKEND, FACILEBACKUP_RETENTION
#
# Local variables:
#
#    n, full_path, backend, branch, full_path
#

function facilebackup_get_numbered_branch()
{
	local n="$1"
	local full_path="$2"
	local backend="$FACILEBACKUP_BACKEND"
	local branch

	branch="$(
		$BASHLETS_NAMESPACE integer to_string "$n" "$FACILEBACKUP_RETENTION"
	)"
	facilebackup_"${backend}_get_path" "$branch" "$full_path"
}


#
# facilebackup_get_head_branch
#
#
# Purpose:
#
#    gets a HEAD backup branch
#
# Example of call:
#
#    facilebackup_get_head_branch
#
# Global variables:
#
#    none
#
# Local variables:
#
#    none
#

function facilebackup_get_head_branch()
{
	facilebackup_get_numbered_branch 0
}


#
# facilebackup_list_branches
#
#
# Purpose:
#
#    lists all available branches
#
# Example of call:
#
#    facilebackup_list_branches
#
# Global variables:
#
#    FACILEBACKUP_RETENTION
#
# Local variables:
#
#    curr, branch_curr
#

function facilebackup_list_branches()
{
	local curr branch_curr

	for curr in $(seq 0 $FACILEBACKUP_RETENTION)
	do
		branch_curr="$(facilebackup_get_numbered_branch "$curr")"
		$(facilebackup_isbranch "$branch_curr") && echo "$branch_curr"
	done
}


#
# facilebackup_create_branch
#
#
# Purpose:
#
#    creates a backup branch
#
# Example of call:
#
#    facilebackup_create_branch <TARGET>
#
# Global variables:
#
#    FACILEBACKUP_BACKEND
#
# Local variables:
#
#    target, backend, magic
#

function facilebackup_create_branch()
{
	local target="$1"
	local backend="$FACILEBACKUP_BACKEND"
	local magic=".$($BASHLETS_NAMESPACE myself get_name)"

	facilebackup_"${backend}_create" "$target"
	facilebackup_"${backend}_touch" "$target" "$magic"
}


#
# facilebackup_copy_branch
#
#
# Purpose:
#
#    copies a backup branch
#
# Example of call:
#
#    facilebackup_copy_branch <SOURCE> <TARGET>
#
# Global variables:
#
#    FACILEBACKUP_BACKEND
#
# Local variables:
#
#    source, target
#

function facilebackup_copy_branch()
{
	local source="$1"
	local target="$2"
	local backend="$FACILEBACKUP_BACKEND"

	facilebackup_"${backend}_copy" "$source" "$target"
}


#
# facilebackup_move_branch
#
#
# Purpose:
#
#    moves a backup branch
#
# Example of call:
#
#    facilebackup_move_branch <SOURCE> <TARGET>
#
# Global variables:
#
#    FACILEBACKUP_BACKEND
#
# Local variables:
#
#    source, target
#

function facilebackup_move_branch()
{
	local source="$1"
	local target="$2"
	local backend="$FACILEBACKUP_BACKEND"

	facilebackup_"${backend}_move" "$source" "$target"
}


#
# facilebackup_delete_branch
#
#
# Purpose:
#
#    deletes a backup branch
#
# Example of call:
#
#    facilebackup_delete_branch <SOURCE>
#
# Global variables:
#
#    FACILEBACKUP_BACKEND, FACILEBACKUP_USE_TRASH
#
# Local variables:
#
#    source, backend, use_trash, target, uuid
#

function facilebackup_delete_branch()
{
	local source="$1"
	local backend="$FACILEBACKUP_BACKEND"
	local use_trash="$FACILEBACKUP_USE_TRASH"
	local target
	local uuid

	$BASHLETS_NAMESPACE string to_bool "$use_trash" || {
		uuid=$($BASHLETS_NAMESPACE uuid create)
		target="${source}.${uuid}.trash"
		facilebackup_"${backend}_move" "$source" "$target"
		return $?
	}

	facilebackup_"${backend}_remove" "$source"
}


#
# Backup rotation
#
################################################################################

#
# facilebackup_rotate_branches
#
#
# Purpose:
#
#    performs rotation of branches
#
# Example of call:
#
#    rotate_backups_branches
#
# Global variables:
#
#    FACILEBACKUP_RETENTION
#
# Local variables:
#
#    curr, next, branch_curr, branch_next
#

function facilebackup_rotate_branches()
{
	local curr next
	local branch_head branch_curr branch_next

	branch_head="$(facilebackup_get_head_branch)"

	for curr in $(seq $FACILEBACKUP_RETENTION -1 1)
	do
		branch_curr="$(facilebackup_get_numbered_branch "$curr")"
		if $(facilebackup_isbranch "$branch_curr")
		then
			if [[ "$curr" -ge "$retention" ]]
			then
				facilebackup_delete_branch "$branch_curr"
			else
				next=$((curr+1))
				branch_next="$(facilebackup_get_numbered_branch "$next")"
				facilebackup_move_branch "$branch_curr" "$branch_next"
			fi
		fi
	done

	facilebackup_isbranch "$branch_head"                                 \
		&& facilebackup_copy_branch "$branch_head" "$branch_curr"        \
		|| facilebackup_create_branch "$branch_head"
}


#
# Command handlers
#
################################################################################

#
# facilebackup_cmd_create
#
#
# Purpose:
#
#    handles the command verb CREATE
#
# Example of call:
#
#    facilebackup_cmd_create <OBJECT> <ARGUMENT>
#
# Global variables:
#
#    none
#
# Local variables:
#
#    object, argument
#

function facilebackup_cmd_create()
{
	echo "Currently unimplemented!"  # TODO
}


#
# facilebackup_cmd_get
#
#
# Purpose:
#
#    handles the command verb GET
#
# Example of call:
#
#    facilebackup_cmd_get <OBJECT> <ARGUMENT>
#
# Global variables:
#
#    none
#
# Local variables:
#
#    argv, object, argument
#

function facilebackup_cmd_get()
{
    local argv="${!1}"
	local object="${argv[1]}"
	local argument="${$argv[2]}"

	case "$object" in
		"branch")
			[[ $argument == head ]] && argument=0
			facilebackup_get_numbered_branch $argument
			;;
		*)
			return $BASHLETS_UX_REPL_ERR_INVALID_ARG
			;;
	esac
}


#
# facilebackup_cmd_list
#
#
# Purpose:
#
#    handles the command verb LIST
#
# Example of call:
#
#    facilebackup_cmd_list <OBJECT> <ARGUMENT>
#
# Global variables:
#
#    none
#
# Local variables:
#
#    argv, object, argument
#

function facilebackup_cmd_list()
{
    local argv="${!1}"
	local object="${argv[1]}"
	local argument="${$argv[2]}"

	case "$object" in
		"backends")
			facilebackup_list_backends
			;;
		"branches")
			facilebackup_list_branches
			;;
		*)
			return $BASHLETS_UX_REPL_ERR_INVALID_ARG
			;;
	esac
}


#
# facilebackup_cmd_rotate
#
#
# Purpose:
#
#    handles the command verb ROTATE
#
# Example of call:
#
#    facilebackup_cmd_rotate <OBJECT> <ARGUMENT>
#
# Global variables:
#
#    none
#
# Local variables:
#
#    argv, object, argument
#

function facilebackup_cmd_rotate()
{
    local argv="${!1}"
	local object="${argv[1]}"
	local argument="${$argv[2]}"

	# provides a default object
	[[ -z $object ]] && object=branches

	case "$object" in
		"branches")
			facilebackup_rotate_branches
			;;
		*)
			return $BASHLETS_UX_REPL_ERR_INVALID_ARG
			;;
	esac
}


#
# facilebackup_cmd_set
#
#
# Purpose:
#
#    handles the command verb SET
#
# Example of call:
#
#    facilebackup_cmd_set <OBJECT> <ARGUMENT>
#
# Global variables:
#
#    none
#
# Local variables:
#
#    argv, object, argument
#

function facilebackup_cmd_set()
{
    local argv="${!1}"
	local object="${argv[1]}"
	local argument="${$argv[2]}"

	case "$object" in
		"backend")
			FACILEBACKUP_BACKEND="$argument"
			;;
		"debug")
			$BASHLETS_NAMESPACE string to_bool "$argument" && set -x || set +x
			;;
		*)
			return $BASHLETS_UX_REPL_ERR_INVALID_ARG
			;;
	esac
}


#
# parsing of command line options
################################################################################

while getopts "B:M:hV" OPTION
do
    case $OPTION in
		B)
			BACKEND="$OPTARG"
			;;
		M)
			MANIFEST="$OPTARG"
			;;
		h)
			echo ; version
			echo ; usage
			exit 0
			;;
		V)
			version
			exit
			;;
    esac
done



#
# init
################################################################################

function facilebackup_init()
{
	function facilebackup_parse_manifest()
	{
		local manifest="$MANIFEST"

		RETENTION="$(
			$BASHLETS_NAMESPACE yaml get_by_key "$manifest" repository_retention
		)"
	}

	facilebackup_parse_manifest

	for backend in $(facilebackup_list_backends)
	do
		"facilebackup_${backend}_init"
	done

	unset facilebackup_parse_manifest
}


facilebackup_init "$MANIFEST"



#
# main loop
################################################################################

repl=$($BASHLETS_NAMESPACE repl create)

$BASHLETS_NAMESPACE repl set_verb $repl create facilebackup_cmd_create
$BASHLETS_NAMESPACE repl set_verb $repl get    facilebackup_cmd_get
$BASHLETS_NAMESPACE repl set_verb $repl list   facilebackup_cmd_list
$BASHLETS_NAMESPACE repl set_verb $repl rotate facilebackup_cmd_rotate
$BASHLETS_NAMESPACE repl set_verb $repl set    facilebackup_cmd_set

$BASHLETS_NAMESPACE repl set_help_for_verb $repl create "unimplemented"
$BASHLETS_NAMESPACE repl set_help_for_verb $repl get    "gets a branch"
$BASHLETS_NAMESPACE repl set_help_for_verb $repl list   "lists backends or branches"
$BASHLETS_NAMESPACE repl set_help_for_verb $repl rotate "rotate branches"
$BASHLETS_NAMESPACE repl set_help_for_verb $repl set    "sets configuration values"

$BASHLETS_NAMESPACE repl start $repl $FACILEBACKUP_PROMPT


# ex: ts=4 sw=4 et filetype=sh noexpandtab
